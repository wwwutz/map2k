GRAVITY

wegen weil:

 L3    up =>  left =>    up (45+24+33) score:102 hsc:102
 L3    up =>  left =>  down (45+24+33) score:102 hsc:102
 L3  down =>  left =>    up (45+24+33) score:102 hsc:102
 L3  down =>  left =>  down (45+24+33) score:102 hsc:102

XXX found [up] as good as [down] XXX

### best move is ^^ up scoring 102 ###  up=102  right=0  down=102  left=97
  0  0  0  1 :      _     _     _     2
  0  0  0  0 :      _     _     _     _
  0  0  1  3 :      _     _     2     8
  0  0  2  3 :      _     _     4     8
Score: 24 / 10

[up] und [down] geben zwar gleichen score, aber in dem fall ist es schlauer
 zu clustern, also eher runter zu den anderen. eben da wo mehr sind.

 --->
wenn 2 richtungen gleichen score ergeben, dann nimm die mit den hoechsten
 werten auf ihrer haelfte.
 
 
 
 0 1 2 3
 4 5 6 7
 8 9 a b
 c d e f
 
 UP : sum( 0-7 )
 DN : sum( 8-f )
 LF : sum( 01,45,89,cd )
 RT : sum( 23,67,ab,ef )
 
 gravity mappen ?
 
 richtung = gravity(uint64_t f)

 oder
 
 int dir_weight[4]; [UP,RT,DN,LF];
 weight( uint64_t f, &dir_weight )
   - was wenn UL = DR ( abef = 0x1111 )
   -- maximal 2 ergebnisse, L,R,U,D,LU,LD,RU,RD
   -- dennoch koennen die summen interessant sein, wenn auch ein einsamer 2048er
      auf 0 und lauter 2'n auf ( 8-f ) ne lustige konstellation sind.
 
 oder
 
 MAP_WEIGHT[0xFFFF]; wie score, wird bei UD/LR mitberechnet und in die f_st eingetragen
   - nett, dummerweise brauche ich die nur wenn der score gleich ist. das is weitaus seltener also overhead.
 
 maximalgewicht = haelfte feld = 8x 2**14
 
 
BACKTRACKERWERTIGKEIT

 tiefe T=2
 
 t= :   1     2            1     2
 2-t:   1     0            1     0       
       2+2 / 0+0 = 4.1    1++ / 0+0 = 2.1
       0-0 / 2+2 = 4.0    0+0 / 1++ = 2.0
       4+4 / 0+0 = 8.1    2++ / 0+0 = 3.1
       2+2 / 2+2 = 8.1    1++ / 1++ = 4.0
       
       score= 10*sc + (T-t)

BITSTUFF


           //0123456789ABCDEF
  r |= f & 0x000000000000F000 << 12; // C=0 L 0 1100
  r |= f & 0x00000000F0000000 << 7;  // 8=1 L 0 0111
  r |= f & 0x0000F00000000000 << 2;  // 4=2 L 0 0010
  r |= f & 0xF000000000000000 >> 3;  // 0=3 R 1 0011
  r |= f & 0x0000000000000F00 << 9;  // D=4 L 0 1001
  r |= f & 0x000000000F000000 << 4;  // 9=5 L 0 0100
  r |= f & 0x00000F0000000000 >> 1;  // 5=6 R 1 0001
  r |= f & 0x0F00000000000000 >> 6;  // 1=7 R 1 0110
  r |= f & 0x00000000000000F0 << 6;  // E=8 L 0 0110
  r |= f & 0x0000000000F00000 << 1;  // A=9 L 0 0001
  r |= f & 0x000000F000000000 >> 4;  // 6=A R 1 0100
  r |= f & 0x00F0000000000000 >> 8;  // 2=B R 1 1000
  r |= f & 0x000000000000000F << 3;  // F=C L 0 0011
  r |= f & 0x00000000000F0000 >> 1;  // B=D R 1 0001
  r |= f & 0x0000000F00000000 >> 7;  // 7=E R 1 0111
  r |= f & 0x000F000000000000 >> 12; // 3=F R 1 1100
  



           //0123456789ABCDEF
  r |= f & 0x0000000000F00000 << 1;  // A=9 L 0 0001
  r |= f & 0x0000F00000000000 << 2;  // 4=2 L 0 0010
  r |= f & 0x000000000000000F << 3;  // F=C L 0 0011
  r |= f & 0x000000000F000000 << 4;  // 9=5 L 0 0100
  r |= f & 0x00000000F0000000 << 7;  // 8=1 L 0 0111
  r |= f & 0x0000000000000F00 << 9;  // D=4 L 0 1001
  r |= f & 0x000000000000F000 << 12; // C=0 L 0 1100
  r |= f & 0x00000000000000F0 << 6;  // E=8 L 0 0110

  r |= f & 0xF000000000000000 >> 3;  // 0=3 R 1 0011
  r |= f & 0x000000F000000000 >> 4;  // 6=A R 1 0100
  r |= f & 0x00F0000000000000 >> 8;  // 2=B R 1 1000
  r |= f & 0x00000F0000000000 >> 1;  // 5=6 R 1 0001
  r |= f & 0x0F00000000000000 >> 6;  // 1=7 R 1 0110
  r |= f & 0x00000000000F0000 >> 2;  // B=D R 1 0001
  r |= f & 0x0000000F00000000 >> 7;  // 7=E R 1 0111
  r |= f & 0x000F000000000000 >> 12; // 3=F R 1 1100

sortiert nach schieberichtung / position

  r |= f & 0x0000F00000000000 << 2;  // 4=2 L 0 0010
  r |= f & 0x00000000F0000000 << 7;  // 8=1 L 0 0111
  r |= f & 0x000000000F000000 << 4;  // 9=5 L 0 0100
  r |= f & 0x0000000000F00000 << 1;  // A=9 L 0 0001
  r |= f & 0x000000000000F000 << 12; // C=0 L 0 1100
  r |= f & 0x0000000000000F00 << 9;  // D=4 L 0 1001
  r |= f & 0x00000000000000F0 << 6;  // E=8 L 0 0110
  r |= f & 0x000000000000000F << 3;  // F=C L 0 0011

  r |= f & 0xF000000000000000 >> 3;  // 0=3 R 1 0011
  r |= f & 0x0F00000000000000 >> 6;  // 1=7 R 1 0110
  r |= f & 0x00F0000000000000 >> 9;  // 2=B R 1 1001
  r |= f & 0x000F000000000000 >> 12; // 3=F R 1 1100
  r |= f & 0x00000F0000000000 >> 1;  // 5=6 R 1 0001
  r |= f & 0x000000F000000000 >> 4;  // 6=A R 1 0100
  r |= f & 0x0000000F00000000 >> 7;  // 7=E R 1 0111
  r |= f & 0x00000000000F0000 >> 2;  // B=D R 1 0010


sortiert nach maske

  r |= f & 0xF000000000000000 >> 3;  // 0=3 R 1 0011
  r |= f & 0x0F00000000000000 >> 6;  // 1=7 R 1 0110
  r |= f & 0x00F0000000000000 >> 9;  // 2=B R 1 1001
  r |= f & 0x000F000000000000 >> 12; // 3=F R 1 1100
  r |= f & 0x0000F00000000000 << 2;  // 4=2 L 0 0010
  r |= f & 0x00000F0000000000 >> 1;  // 5=6 R 1 0001
  r |= f & 0x000000F000000000 >> 4;  // 6=A R 1 0100
  r |= f & 0x0000000F00000000 >> 7;  // 7=E R 1 0111
  r |= f & 0x00000000F0000000 << 7;  // 8=1 L 0 0111
  r |= f & 0x000000000F000000 << 4;  // 9=5 L 0 0100
  r |= f & 0x0000000000F00000 << 1;  // A=9 L 0 0001
  r |= f & 0x00000000000F0000 >> 2;  // B=D R 1 0010
  r |= f & 0x000000000000F000 << 12; // C=0 L 0 1100
  r |= f & 0x0000000000000F00 << 9;  // D=4 L 0 1001
  r |= f & 0x00000000000000F0 << 6;  // E=8 L 0 0110
  r |= f & 0x000000000000000F << 3;  // F=C L 0 0011


sortiert nach anzahl shifts

  r |= f & 0x00000F0000000000 >> 1;  // 5=6 R 1 0001
  r |= f & 0x0000000000F00000 << 1;  // A=9 L 0 0001
  r |= f & 0x00000000000F0000 >> 2;  // B=D R 1 0010
  r |= f & 0x0000F00000000000 << 2;  // 4=2 L 0 0010
  r |= f & 0xF000000000000000 >> 3;  // 0=3 R 1 0011
  r |= f & 0x000000000000000F << 3;  // F=C L 0 0011
  r |= f & 0x000000F000000000 >> 4;  // 6=A R 1 0100
  r |= f & 0x000000000F000000 << 4;  // 9=5 L 0 0100
  r |= f & 0x0F00000000000000 >> 6;  // 1=7 R 1 0110
  r |= f & 0x00000000000000F0 << 6;  // E=8 L 0 0110
  r |= f & 0x0000000F00000000 >> 7;  // 7=E R 1 0111
  r |= f & 0x00000000F0000000 << 7;  // 8=1 L 0 0111
  r |= f & 0x00F0000000000000 >> 9;  // 2=B R 1 1001
  r |= f & 0x0000000000000F00 << 9;  // D=4 L 0 1001
  r |= f & 0x000F000000000000 >> 12; // 3=F R 1 1100
  r |= f & 0x000000000000F000 << 12; // C=0 L 0 1100

sortiert nach richtung / anzahl shifts

  r |= f & 0x00000F0000000000 >> 1;  // 5=6 R 1 0001
  r |= f & 0x00000000000F0000 >> 2;  // B=D R 1 0010
  r |= f & 0xF000000000000000 >> 3;  // 0=3 R 1 0011
  r |= f & 0x000000F000000000 >> 4;  // 6=A R 1 0100
  r |= f & 0x0F00000000000000 >> 6;  // 1=7 R 1 0110
  r |= f & 0x0000000F00000000 >> 7;  // 7=E R 1 0111
  r |= f & 0x00F0000000000000 >> 9;  // 2=B R 1 1001
  r |= f & 0x000F000000000000 >> 12; // 3=F R 1 1100

  r |= f & 0x0000000000F00000 << 1;  // A=9 L 0 0001
  r |= f & 0x0000F00000000000 << 2;  // 4=2 L 0 0010
  r |= f & 0x000000000000000F << 3;  // F=C L 0 0011
  r |= f & 0x000000000F000000 << 4;  // 9=5 L 0 0100
  r |= f & 0x00000000000000F0 << 6;  // E=8 L 0 0110
  r |= f & 0x00000000F0000000 << 7;  // 8=1 L 0 0111
  r |= f & 0x0000000000000F00 << 9;  // D=4 L 0 1001
  r |= f & 0x000000000000F000 << 12; // C=0 L 0 1100



  f >>= 1; r |= f & 0x0000 00F0 0000 0000;  // 5=6
  f >>= 1; r |= f & 0x0000 0000 0000 0F00;  // B=D
  f >>= 1; r |= f & 0x00F0 0000 0000 0000;  // 0=3
  f >>= 1; r |= f & 0x0000 0000 00F0 0000;  // 6=A
  f >>= 2; r |= f & 0x0000 000F 0000 0000;  // 1=7
  f >>= 1; r |= f & 0x0000 0000 0000 00F0;  // 7=E
  f >>= 2; r |= f & 0x0000 0000 000F 0000;  // 2=B
  f >>= 3; r |= f & 0x0000 0000 0000 000F;  // 3=F


rot pointer field of nibbles

static uint8_t RV[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
static uint8_t LV[] = { 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };
static uint8_t DV[] = { 12, 8, 4, 0, 13, 9, 5, 1, 14, 10, 6, 2, 15, 11, 7, 3 };
static uint8_t UV[] = { 3, 7, 11, 15, 2, 6, 10, 14, 1, 5, 9, 13, 0, 4, 8, 12 };

uint64_t RVx = 0x0123456789ABCDEF;
uint64_t LVx = 0xFEDCBA9876543210;
uint64_t DVx = 0xC840D951EA62FB73;
uint64_t UVx = 0x37BF26AE159D048C;

uint64_t ROT[] = {RVx,LVx,DVx,UVx};

int r;
for (r=0;r<=3;r++) {
  for (i=0;i<=15;i++) {

  }
}




